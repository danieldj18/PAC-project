function PAC = calculatePAC_mst_fast(signal1, signal2, samplingFrequency, LFrange, LFwidth, ...
    LF_stepsize, HFrange, HFwidth, HF_stepsize, nShuffles, samplesToUse, printsteps)

    %{
        This function calculates Phase-Amplitude Coupling (PAC) using the Modulation Index (MI) described by Tort et al., 2010.
    
        Inputs:
        - signal1: For calculating phase of LF.
        - signal2: For calculating amplitude of HF.
        - samplingFrequency: The sampling frequency of the signals (in Hz).
        - LFrange: Range of low-frequency oscillations (e.g., theta band) [minLF, maxLF] in Hz.
        - LFwidth: Width of each LF band window (e.g., 2 Hz).
        - HFrange: Range of high-frequency oscillations (e.g., gamma band) [minHF, maxHF] in Hz.
        - HFwidth: Width of each HF band window (e.g., 10 Hz).
        - nShuffles: Number of times to shuffle the phase data for surrogate analysis.
        - samplesToUse: Logical array that indicates which samples to include in the PAC calculation (1 = include, 0 = exclude).
    
        Output:
          - PAC: A struct containing PAC results.

          - dimensionInfo: A string describing the dimensional structure of the data. '2D: LF x HF ; 3D: LF x HF x phaseBin' 
                           indicates that MI is stored in 2D matrices (LF x HF), and phase-specific data in 3D matrices (LF x HF x phaseBin).
        
          - LF_frequencyCenters: A vector of low-frequency (LF) center values (1D).
        
          - HF_frequencyCenters: A vector of high-frequency (HF) center values (1D).
        
          - MI: A 2D matrix (size: [LF x HF])
        
          - MI_pVal: A 2D matrix (size: [LF x HF]) containing p-values for the statistical significance of each MI value.
                     The p-value is calculated based on surrogate data and represents the likelihood that the observed MI
                     could have occurred by chance.
        
          - MIsurrMean: A 2D matrix (size: [LF x HF]) representing the mean MI value from the surrogate data (shuffled LF phase).
                        This is used to compare the observed MI with the distribution of MI values generated by chance.
                                        ***This will be used to generated the fig.7 (a) in the Stangl paper***
        
          - MIsurrStd: A 2D matrix (size: [LF x HF]) representing the standard deviation of MI values from the surrogate data.
                       It measures the variability in MI values across multiple shuffles.
        
          - meanHFampPerLFphaseBin: A 3D matrix (size: [LF x HF x phaseBin]) representing the mean high-frequency (HF) amplitude 
                                    for each phase bin of the low-frequency (LF) oscillation.
                                        ***This will be used to generated the fig.7 (b) in the Stangl paper***
                                        [LF x HF x phaseBin] == take mean across LF ==> [HF x phase bin]
        
          - nSamplesPerLFphaseBin: A 3D matrix (size: [LF x HF x phaseBin]) that stores the number of samples in each LF phase bin 
                                   used for calculating the mean HF amplitude.
        
          - meanHFampPerLFphaseBin_surr: A 3D matrix (size: [LF x HF x phaseBin]) representing the mean high-frequency (HF) amplitude 
                                         across phase bins from surrogate data (shuffled phase).
        
          - stdHFampPerLFphaseBin_surr: A 3D matrix (size: [LF x HF x phaseBin]) representing the standard deviation of the HF amplitude 
                                        in the surrogate data.
    %}
    
    % --------------------
    % SETTINGS
    nPhaseBins = 18; % Number of phase bins for categorizing the low-frequency phase (e.g., dividing -π to π into 18 bins)
    nSamplesPerShufflingSegment = samplingFrequency; % Length of each segment (number of samples) for phase shuffling (1 second if using the sampling frequency)
    % --------------------
    
    % Step 1: Define frequency center points for the low- and high-frequency bands
    LF_frequencyCenters = LFrange(1) : LF_stepsize : LFrange(2); 
    HF_frequencyCenters = HFrange(1) : HF_stepsize : HFrange(2); 
    
    % Step 2: Prepare the PAC output structure
    PAC.dimensionInfo = '2D: LF x HF ; 3D: LF x HF x phaseBin';
    PAC.LF_frequencyCenters = LF_frequencyCenters; 
    PAC.HF_frequencyCenters = HF_frequencyCenters; 
    PAC.MI =            nan(length(LF_frequencyCenters), length(HF_frequencyCenters)); 
    PAC.MIsurr =        nan(length(LF_frequencyCenters), length(HF_frequencyCenters), nShuffles); 
    PAC.MI_pVal =       nan(length(LF_frequencyCenters), length(HF_frequencyCenters));
    PAC.MIsurrMean =	nan(length(LF_frequencyCenters), length(HF_frequencyCenters));
    PAC.MIsurrStd =     nan(length(LF_frequencyCenters), length(HF_frequencyCenters)); 
    PAC.meanHFampPerLFphaseBin =        nan(length(LF_frequencyCenters), length(HF_frequencyCenters), nPhaseBins); 
    PAC.nSamplesPerLFphaseBin =         nan(length(LF_frequencyCenters), length(HF_frequencyCenters), nPhaseBins); 
    PAC.meanHFampPerLFphaseBin_surr =	nan(length(LF_frequencyCenters), length(HF_frequencyCenters), nPhaseBins); 
    PAC.stdHFampPerLFphaseBin_surr =	nan(length(LF_frequencyCenters), length(HF_frequencyCenters), nPhaseBins);
    
    % Step 2.5: Convert signals to GPU if enabled (faster)
    useGPU = false;
    if useGPU
        signal1 = gpuArray(signal1);
        signal2 = gpuArray(signal2);
        samplesToUse = gpuArray(samplesToUse);
    end

    % Step 3: Loop through all low-frequency (LF) and high-frequency (HF) combinations to calculate PAC
    stepCounter = 0; 
    
    for iLF = 1:length(LF_frequencyCenters)
    
        % Define the current low-frequency band (e.g., theta range)
        currentLFwindow = [LF_frequencyCenters(iLF)-LFwidth/2, LF_frequencyCenters(iLF) + LFwidth/2];
    
        for iHF = 1 : length(HF_frequencyCenters)
    
            % Define the current high-frequency band (e.g., gamma range)
            currentHFwindow = [HF_frequencyCenters(iHF)-HFwidth/2, HF_frequencyCenters(iHF)+HFwidth/2];
            
            stepCounter = stepCounter + 1; % track
            
            if printsteps
                % Display the current frequency combination being processed
                disp(['PAC: ' num2str(LF_frequencyCenters(iLF)) 'Hz with ' num2str(HF_frequencyCenters(iHF))...
                    'Hz (step ' num2str(stepCounter) ' of ' num2str(length(LF_frequencyCenters)...
                    * length(HF_frequencyCenters)) ')']);
            end
    
            % Step 4: Filter signal
            % Filter signal to get the low-frequency component (for phase)
            LFsignal = zscore(eegfilt(signal1, samplingFrequency, currentLFwindow(1), currentLFwindow(2)));
            
            % Filter signal to get the high-frequency component (for amplitude)
            HFsignal = zscore(eegfilt(signal2, samplingFrequency, currentHFwindow(1), currentHFwindow(2)));
    
            % Step 5: Apply Hilbert transform to extract phase and amplitude
            % Hilbert transform to get the instantaneous phase of LF signal
            LF_phase = angle(hilbert(LFsignal)); 
            
            % Hilbert transform to get the instantaneous amplitude of HF signal
            HF_amplitude = abs(hilbert(HFsignal));
            
            % Step 6: Exclude samples that are unwanted (e.g., artifacts or specific conditions)
            LF_phase = LF_phase(logical(samplesToUse)); % convert to boolean
            HF_amplitude = HF_amplitude(logical(samplesToUse));
            
            % Step 7: Calculate the Modulation Index (MI) for phase-amplitude coupling
            [MI, meanHFampPerLFphaseBin, nSamplesPerLFphaseBin] = calcModulationIndex_Tort2010(LF_phase, HF_amplitude, nPhaseBins);
            
            % Step 8: Perform surrogate analysis by shuffling the LF phase to generate surrogate data
            % This will help to compute p-values for significance testing
            LFphase_tXsegment = LF_phase; % For example, [1 2 3 2 1 ...]
            nShufflingSegments = ceil(length(LFphase_tXsegment) / nSamplesPerShufflingSegment); 
            nNansToFillLastSegment = (nShufflingSegments * nSamplesPerShufflingSegment) - length(LFphase_tXsegment); 
            LFphase_tXsegment = [LFphase_tXsegment nan(1,nNansToFillLastSegment)]; % Add NaNs to pad to a full segment
            LFphase_tXsegment = reshape(LFphase_tXsegment, nSamplesPerShufflingSegment, nShufflingSegments); 
    
            % Pre-allocate surrogate MI arrays
            MI_surr = nan(1, nShuffles); 
            meanHFampPerLFphaseBin_surr = nan(nShuffles, nPhaseBins);
            nSamplesPerLFphaseBin_surr = nan(nShuffles, nPhaseBins);
    
            % Loop through each shuffle iteration
            parfor iShuf = 1:nShuffles
                
                % Shuffle the phase data by randomizing the order of the segments
                LFphase_shuffled = LFphase_tXsegment(:, randperm(nShufflingSegments)); % Randomly permute columns (segments)
                LFphase_shuffled = LFphase_shuffled(~isnan(LFphase_shuffled(:)))'; % Flatten and remove NaNs
                
                % Calculate surrogate MI for the shuffled phase data
                [MI_surr(iShuf), meanHFampPerLFphaseBin_surr(iShuf,:), nSamplesPerLFphaseBin_surr(iShuf,:)] = ...
                    calcModulationIndex_Tort2010(LFphase_shuffled, HF_amplitude, nPhaseBins);
            end

            % Step 8.5 Store all surrogate MIs for this LF-HF combination
            PAC.MIsurr(iLF, iHF, :) = MI_surr;
            
            % Step 9: Compute the p-value for the MI based on the surrogate distribution
            pVal = sum(MI_surr >= MI) / length(MI_surr); 
            
            % Step 10: Store results in the PAC structure
            PAC.MI(iLF,iHF) = MI; 
            PAC.MI_pVal(iLF,iHF) = pVal;
            PAC.MIsurrMean(iLF,iHF) = mean(MI_surr);
            PAC.MIsurrStd(iLF,iHF) = std(MI_surr); 
    
            PAC.meanHFampPerLFphaseBin(iLF, iHF, :) = meanHFampPerLFphaseBin;
            PAC.nSamplesPerLFphaseBin(iLF, iHF, :) = nSamplesPerLFphaseBin;
            
            PAC.meanHFampPerLFphaseBin_surr(iLF, iHF, :) = mean(meanHFampPerLFphaseBin_surr);
            PAC.stdHFampPerLFphaseBin_surr(iLF, iHF, :) = std(meanHFampPerLFphaseBin_surr);
    
        end
    end



